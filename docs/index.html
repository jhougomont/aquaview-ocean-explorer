<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AQUAVIEW Gulf Ocean Intelligence Explorer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e1a; color: #e0e6f0; font-family: 'Inter', sans-serif; overflow: hidden; height: 100vh; width: 100vw; }
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1; }
        #current-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 420; }

        /* â”€â”€â”€ Title Bar â”€â”€â”€ */
        .title-bar { position: absolute; top: 16px; left: 60px; z-index: 1000; display: flex; align-items: center; gap: 12px; }
        .title-bar h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.02em; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,0.5); }
        .title-bar .badge { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: #38bdf8; background: rgba(56,189,248,0.15); border: 1px solid rgba(56,189,248,0.3); padding: 3px 10px; border-radius: 20px; }
        .title-bar .about-btn { font-size: 11px; font-weight: 500; color: #94a3b8; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); padding: 5px 14px; border-radius: 20px; cursor: pointer; transition: all 0.2s; text-decoration: none; }
        .title-bar .about-btn:hover { color: #e0e6f0; background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.2); }

        /* â”€â”€â”€ Layer Panel â”€â”€â”€ */
        .layer-panel { position: absolute; top: 16px; right: 16px; z-index: 1000; background: rgba(10, 14, 26, 0.92); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px 14px; width: 270px; max-height: calc(100vh - 100px); overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
        .layer-panel::-webkit-scrollbar { width: 4px; }
        .layer-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

        .layer-group-header {
            font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em;
            color: #64748b; padding: 8px 0 4px; margin-top: 6px; cursor: pointer;
            display: flex; align-items: center; gap: 6px; user-select: none;
        }
        .layer-group-header:first-child { margin-top: 0; }
        .layer-group-header .chevron { transition: transform 0.2s; font-size: 8px; }
        .layer-group-header .chevron.collapsed { transform: rotate(-90deg); }
        .layer-group-header:hover { color: #94a3b8; }
        .layer-group-body { overflow: hidden; transition: max-height 0.25s ease; }
        .layer-group-body.collapsed { max-height: 0 !important; }

        .layer-toggle { display: flex; align-items: center; gap: 8px; padding: 4px 0; cursor: pointer; font-size: 12px; transition: opacity 0.15s; }
        .layer-toggle:hover { opacity: 0.8; }
        .layer-toggle .dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; border: 2px solid currentColor; transition: all 0.15s; }
        .layer-toggle.active .dot { background: currentColor; box-shadow: 0 0 6px currentColor; }
        .layer-toggle .label { flex: 1; }
        .layer-toggle .count { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #64748b; }

        /* â”€â”€â”€ Stats Bar â”€â”€â”€ */
        .stats-bar { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; gap: 2px; background: rgba(10,14,26,0.88); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; padding: 4px; }
        .stat-chip { padding: 6px 12px; border-radius: 8px; font-size: 11px; display: flex; align-items: center; gap: 5px; white-space: nowrap; }
        .stat-chip .num { font-family: 'JetBrains Mono', monospace; font-weight: 600; font-size: 13px; }
        .stat-chip .lbl { color: #94a3b8; font-size: 10px; }

        /* â”€â”€â”€ Loading â”€â”€â”€ */
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 2000; background: #0a0e1a; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s; }
        .loading-overlay.hidden { opacity: 0; pointer-events: none; }
        .loading-text { font-size: 14px; color: #64748b; margin-top: 20px; }
        .loading-bar { width: 200px; height: 3px; background: rgba(255,255,255,0.08); border-radius: 2px; margin-top: 12px; overflow: hidden; }
        .loading-bar .fill { height: 100%; width: 30%; background: linear-gradient(90deg, #38bdf8, #818cf8); border-radius: 2px; animation: loadSlide 1.2s ease-in-out infinite; }
        @keyframes loadSlide { 0% { transform: translateX(-100%); } 100% { transform: translateX(400%); } }

        /* â”€â”€â”€ Leaflet Overrides â”€â”€â”€ */
        .leaflet-control-zoom { display: none; }
        .leaflet-control-attribution { background: rgba(10,14,26,0.7) !important; color: #475569 !important; font-size: 10px !important; }
        .leaflet-control-attribution a { color: #64748b !important; }
        .leaflet-popup-content-wrapper { background: rgba(10,14,26,0.95); color: #e0e6f0; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 8px 24px rgba(0,0,0,0.5); }
        .leaflet-popup-tip { background: rgba(10,14,26,0.95); }
        .leaflet-popup-content { font-family: 'Inter', sans-serif; font-size: 13px; }
        .do-label { background: none !important; border: none !important; box-shadow: none !important; font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: 700; color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 0 2px rgba(0,0,0,0.8); padding: 0 !important; }
        .do-label::before { display: none !important; }
        .hide-do-labels .do-label { display: none !important; }

        /* â”€â”€â”€ Legends â”€â”€â”€ */
        .current-legend { position: absolute; bottom: 70px; right: 16px; z-index: 1000; background: rgba(10,14,26,0.88); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 8px 12px; font-size: 10px; }
        .current-legend .title { font-weight: 600; margin-bottom: 4px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.06em; }
        .current-legend .bar { height: 6px; width: 100px; border-radius: 3px; margin: 3px 0; }
        .current-legend .labels { display: flex; justify-content: space-between; color: #64748b; font-family: 'JetBrains Mono', monospace; }
        .heatmap-legends { position: absolute; bottom: 70px; left: 16px; z-index: 1000; display: flex; flex-direction: column; gap: 6px; }
        .heat-legend { background: rgba(10,14,26,0.90); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 7px 12px; font-size: 10px; min-width: 160px; }
        .heat-legend .hl-title { font-weight: 600; margin-bottom: 3px; text-transform: uppercase; letter-spacing: 0.06em; font-size: 9px; }
        .heat-legend .hl-bar { height: 8px; border-radius: 4px; margin: 3px 0; }
        .heat-legend .hl-labels { display: flex; justify-content: space-between; color: #64748b; font-family: 'JetBrains Mono', monospace; font-size: 9px; }

        /* â”€â”€â”€ About Panel â”€â”€â”€ */
        .about-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 3000; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .about-overlay.visible { opacity: 1; pointer-events: all; }
        .about-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 800px; max-width: calc(100vw - 40px); max-height: calc(100vh - 60px); background: rgba(10, 14, 26, 0.97); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; overflow: hidden; box-shadow: 0 24px 80px rgba(0,0,0,0.6); }
        .about-tabs { display: flex; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .about-tab { flex: 1; padding: 12px 16px; font-size: 12px; font-weight: 500; color: #64748b; text-align: center; cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent; }
        .about-tab:hover { color: #94a3b8; background: rgba(255,255,255,0.03); }
        .about-tab.active { color: #38bdf8; border-bottom-color: #38bdf8; background: rgba(56,189,248,0.05); }
        .about-close { position: absolute; top: 8px; right: 12px; width: 28px; height: 28px; border-radius: 50%; border: none; background: rgba(255,255,255,0.06); color: #94a3b8; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10; transition: all 0.15s; }
        .about-close:hover { background: rgba(255,255,255,0.12); color: #fff; }
        .about-content { padding: 24px 28px; overflow-y: auto; max-height: calc(100vh - 160px); line-height: 1.7; }
        .about-content h2 { font-size: 18px; font-weight: 700; margin-bottom: 6px; color: #fff; }
        .about-content h3 { font-size: 14px; font-weight: 600; margin-top: 20px; margin-bottom: 6px; color: #e0e6f0; }
        .about-content p { font-size: 13px; color: #94a3b8; margin-bottom: 12px; }
        .about-content .hl { color: #38bdf8; font-weight: 500; }
        .about-content .tag { display: inline-block; font-size: 10px; font-weight: 500; padding: 2px 8px; border-radius: 20px; margin: 2px 3px 2px 0; }
        .about-content .data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 14px 0; }
        .about-content .data-card { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); border-radius: 8px; padding: 12px 14px; }
        .about-content .dc-title { font-size: 12px; font-weight: 600; color: #e0e6f0; margin-bottom: 3px; display: flex; align-items: center; gap: 6px; }
        .about-content .dc-detail { font-size: 11px; color: #64748b; line-height: 1.5; }
        .about-content .dc-dot { width: 7px; height: 7px; border-radius: 50%; display: inline-block; }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        /* Wind barb canvas */
        #heat-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 450; }
        #wind-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 440; }
    </style>
</head>
<body>

<div id="map"></div>
<canvas id="current-canvas"></canvas>
<canvas id="heat-canvas"></canvas>
<canvas id="wind-canvas"></canvas>

<div class="title-bar">
    <h1>AQUAVIEW Ocean Intelligence</h1>
    <span class="badge">Ultimate Gulf COP</span>
    <a class="about-btn" onclick="toggleAbout()">About</a>
</div>

<!-- â•â•â•â•â•â•â• LAYER PANEL â•â•â•â•â•â•â• -->
<div class="layer-panel" id="layer-panel">

    <div class="layer-group-header" onclick="toggleGroup('ocean-grp')">
        <span class="chevron" id="chevron-ocean-grp">â–¼</span> Ocean Conditions
    </div>
    <div class="layer-group-body" id="grp-ocean-grp">
        <div class="layer-toggle active" data-layer="sst_heat" style="color:#f97316" onclick="toggleLayer('sst_heat')">
            <div class="dot"></div><span class="label">Sea Temperature</span><span class="count" id="sst-heat-count">â€”</span>
        </div>
        <div class="layer-toggle active" data-layer="do_field" style="color:#22c55e" onclick="toggleLayer('do_field')">
            <div class="dot"></div><span class="label">Dissolved Oxygen</span><span class="count" id="do-count">â€”</span>
        </div>
        <div class="layer-toggle active" data-layer="currents" style="color:#38bdf8" onclick="toggleLayer('currents')">
            <div class="dot"></div><span class="label">Current Flow</span><span class="count" id="currents-status">loading</span>
        </div>
        <div class="layer-toggle" data-layer="water_level" style="color:#06b6d4" onclick="toggleLayer('water_level')">
            <div class="dot"></div><span class="label">Water Level</span><span class="count" id="wl-count">â€”</span>
        </div>
        <div class="layer-toggle" data-layer="wind" style="color:#94a3b8" onclick="toggleLayer('wind')">
            <div class="dot"></div><span class="label">Wind Field</span><span class="count" id="wind-count">â€”</span>
        </div>
        <div class="layer-toggle" data-layer="waves" style="color:#60a5fa" onclick="toggleLayer('waves')">
            <div class="dot"></div><span class="label">Wave Height</span><span class="count" id="wave-count">â€”</span>
        </div>
    </div>

    <div class="layer-group-header" onclick="toggleGroup('sat-grp')">
        <span class="chevron collapsed" id="chevron-sat-grp">â–¼</span> Satellite Products
    </div>
    <div class="layer-group-body collapsed" id="grp-sat-grp">
        <div class="layer-toggle" data-layer="chlorophyll" style="color:#34d399" onclick="toggleLayer('chlorophyll')">
            <div class="dot"></div><span class="label">Chlorophyll-a</span><span class="count">OLCI</span>
        </div>
        <div class="layer-toggle" data-layer="sst" style="color:#f97316" onclick="toggleLayer('sst')">
            <div class="dot"></div><span class="label">SST (VIIRS)</span><span class="count">WMS</span>
        </div>
        <div class="layer-toggle" data-layer="ssh" style="color:#a78bfa" onclick="toggleLayer('ssh')">
            <div class="dot"></div><span class="label">Sea Surface Height</span><span class="count">WMS</span>
        </div>
        <div class="layer-toggle" data-layer="salinity" style="color:#818cf8" onclick="toggleLayer('salinity')">
            <div class="dot"></div><span class="label">Salinity (SMOS)</span><span class="count">WMS</span>
        </div>
        <div class="layer-toggle" data-layer="kd490" style="color:#67e8f9" onclick="toggleLayer('kd490')">
            <div class="dot"></div><span class="label">Water Clarity</span><span class="count">WMS</span>
        </div>
    </div>

    <div class="layer-group-header" onclick="toggleGroup('glider-grp')">
        <span class="chevron" id="chevron-glider-grp">â–¼</span> Glider Fleet
    </div>
    <div class="layer-group-body" id="grp-glider-grp">
        <div class="layer-toggle active" data-layer="glider_bass" style="color:#c084fc" onclick="toggleLayer('glider_bass')">
            <div class="dot"></div><span class="label">Bass</span><span class="count" id="glider-bass-count">â€”</span>
        </div>
        <div class="layer-toggle" data-layer="glider_gansett" style="color:#60a5fa" onclick="toggleLayer('glider_gansett')">
            <div class="dot"></div><span class="label">Gansett</span><span class="count" id="glider-gansett-count">â€”</span>
        </div>
        <div class="layer-toggle active" data-layer="glider_jaialai" style="color:#f472b6" onclick="toggleLayer('glider_jaialai')">
            <div class="dot"></div><span class="label">Jai Alai</span><span class="count" id="glider-jaialai-count">â€”</span>
        </div>
        <div class="layer-toggle" data-layer="glider_sam" style="color:#fb923c" onclick="toggleLayer('glider_sam')">
            <div class="dot"></div><span class="label">Sam</span><span class="count" id="glider-sam-count">â€”</span>
        </div>
        <div class="layer-toggle active" data-layer="glider_stella" style="color:#34d399" onclick="toggleLayer('glider_stella')">
            <div class="dot"></div><span class="label">Stella</span><span class="count" id="glider-stella-count">â€”</span>
        </div>
    </div>

    <div class="layer-group-header" onclick="toggleGroup('hazard-grp')">
        <span class="chevron collapsed" id="chevron-hazard-grp">â–¼</span> Hazards & Events
    </div>
    <div class="layer-group-body collapsed" id="grp-hazard-grp">
        <div class="layer-toggle" data-layer="incidents" style="color:#ef4444" onclick="toggleLayer('incidents')">
            <div class="dot"></div><span class="label">Pollution Incidents</span><span class="count" id="incidents-count">â€”</span>
        </div>
        <div class="layer-toggle" data-layer="pmel" style="color:#f472b6" onclick="toggleLayer('pmel')">
            <div class="dot"></div><span class="label">Hurricane Probes</span><span class="count" id="pmel-count">â€”</span>
        </div>
    </div>

    <div class="layer-group-header" onclick="toggleGroup('raw-grp')">
        <span class="chevron collapsed" id="chevron-raw-grp">â–¼</span> Station Networks
    </div>
    <div class="layer-group-body collapsed" id="grp-raw-grp">
        <div class="layer-toggle" data-layer="ndbc_met" style="color:#fbbf24" onclick="toggleLayer('ndbc_met')">
            <div class="dot"></div><span class="label">NDBC Buoys</span><span class="count" id="ndbc-met-count">â€”</span>
        </div>
        <div class="layer-toggle" data-layer="ioos" style="color:#2dd4bf" onclick="toggleLayer('ioos')">
            <div class="dot"></div><span class="label">IOOS Sensors</span><span class="count" id="ioos-count">â€”</span>
        </div>
    </div>
</div>

<!-- â•â•â•â•â•â•â• STATS BAR â•â•â•â•â•â•â• -->
<div class="stats-bar" id="stats-bar">
    <div class="stat-chip"><span class="num" id="stat-sensors">â€”</span><span class="lbl">sensors</span></div>
    <div class="stat-chip"><span class="num" id="stat-collections">9</span><span class="lbl">collections</span></div>
    <div class="stat-chip"><span class="num" id="stat-layers">22</span><span class="lbl">layers</span></div>
    <div class="stat-chip"><span class="num" id="stat-particles">â€”</span><span class="lbl">particles</span></div>
    <div class="stat-chip"><span class="num" id="stat-updated" style="color:#22c55e;cursor:help" title="">â€”</span><span class="lbl">updated Â· 2hr cycle</span></div>
</div>

<div class="current-legend" id="current-legend">
    <div class="title">Current Speed</div>
    <div class="bar" style="background: linear-gradient(to right, #1e3a5f, #38bdf8, #818cf8, #f472b6, #fbbf24)"></div>
    <div class="labels"><span>0</span><span>0.25</span><span>0.5</span><span>m/s</span></div>
</div>

<!-- â•â•â•â•â•â•â• HEATMAP LEGENDS â•â•â•â•â•â•â• -->
<div class="heatmap-legends" id="heatmap-legends">
    <div class="heat-legend" id="legend-sst" style="display:block">
        <div class="hl-title" style="color:#f97316">Temperature (Â°C)</div>
        <div class="hl-bar" style="background: linear-gradient(to right, #1e3cb4, #50aae6, #32dc14, #f0dc14, #fa6e14, #fa2814)"></div>
        <div class="hl-labels"><span>14</span><span>18</span><span>22</span><span>26</span><span>30</span></div>
    </div>
    <div class="heat-legend" id="legend-do" style="display:block">
        <div class="hl-title" style="color:#22c55e">Dissolved Oxygen (mg/L)</div>
        <div class="hl-bar" style="background: linear-gradient(to right, #dc2828, #f08c28, #fadc28, #50dc46, #32c878)"></div>
        <div class="hl-labels"><span>0</span><span>2</span><span>4</span><span>6</span><span>10</span></div>
    </div>
    <div class="heat-legend" id="legend-wl" style="display:none">
        <div class="hl-title" style="color:#06b6d4">Water Level (m)</div>
        <div class="hl-bar" style="background: linear-gradient(to right, #143cb4, #32a0dc, #6edcd2, #c8b464, #fa9628)"></div>
        <div class="hl-labels"><span>-0.5</span><span>0</span><span>0.5</span><span>1.0</span></div>
    </div>
</div>

<!-- â•â•â•â•â•â•â• ABOUT â•â•â•â•â•â•â• -->
<div class="about-overlay" id="about-overlay" onclick="if(event.target===this)toggleAbout()">
    <div class="about-panel">
        <button class="about-close" onclick="toggleAbout()">&times;</button>
        <div class="about-tabs">
            <div class="about-tab active" onclick="switchTab('aquaview')">Powered by AQUAVIEW</div>
            <div class="about-tab" onclick="switchTab('overview')">COP Overview</div>
            <div class="about-tab" onclick="switchTab('layers')">Data Layers</div>
            <div class="about-tab" onclick="switchTab('tech')">Technology</div>
            <div class="about-tab" onclick="switchTab('models')">ML Models</div>
        </div>

        <div class="about-content tab-pane active" id="tab-aquaview">
            <h2 style="display:flex;align-items:center;gap:10px">
                <span style="font-size:24px">ğŸŒŠ</span> Powered by AQUAVIEW
            </h2>
            <p>This Common Operating Picture would not be possible without <span class="hl">AQUAVIEW</span> â€” a federated ocean data infrastructure that unifies dozens of disparate oceanographic data sources into a single, standards-based discovery layer.</p>

            <h3>What is AQUAVIEW?</h3>
            <p>AQUAVIEW is a geospatial data federation built on the <span class="hl">SpatioTemporal Asset Catalog (STAC)</span> standard. It provides a single, searchable API spanning <span class="hl">24+ oceanographic collections</span> from NOAA, IOOS, CoastWatch, and other providers â€” making it possible to discover and access real-time ocean observations that would otherwise require querying dozens of different APIs, formats, and endpoints.</p>

            <h3>The Problem AQUAVIEW Solves</h3>
            <p>Ocean data is fragmented across agencies, formats, and access protocols. NDBC buoy data lives on one system, CO-OPS tidal stations on another, glider missions on a third, satellite products on yet another. Building a comprehensive operational picture traditionally requires writing and maintaining separate integrations for each. AQUAVIEW collapses this complexity by cataloging all sources into a uniform STAC interface with standardized metadata, bounding-box spatial queries, and direct links to source ERDDAP servers.</p>

            <h3>How This COP Uses AQUAVIEW</h3>
            <p>Every 2 hours, our automated pipeline queries the AQUAVIEW STAC API with a Gulf of Mexico bounding-box filter. For each matching item, AQUAVIEW provides <code>aquaview:source_url</code> pointing to the live ERDDAP endpoint and <code>aquaview:variables</code> listing available parameters. This lets us automatically discover and fetch the latest data across all 9 collections powering this COP â€” without hard-coding a single data source URL.</p>

            <div class="data-grid" style="margin-top:16px">
                <div class="data-card">
                    <div class="dc-title"><span class="dc-dot" style="background:#38bdf8"></span> 24+ Collections</div>
                    <div class="dc-detail">NDBC, CO-OPS, IOOS, CoastWatch, PMEL, Gliders, Incidents, and more â€” all searchable from one endpoint</div>
                </div>
                <div class="data-card">
                    <div class="dc-title"><span class="dc-dot" style="background:#22c55e"></span> STAC Standard</div>
                    <div class="dc-detail">OGC-compliant metadata with spatial/temporal queries, so any STAC client can discover Gulf data</div>
                </div>
                <div class="data-card">
                    <div class="dc-title"><span class="dc-dot" style="background:#f97316"></span> Source-Linked</div>
                    <div class="dc-detail">Each STAC item links directly to the authoritative ERDDAP source â€” no data duplication, always fresh</div>
                </div>
                <div class="data-card">
                    <div class="dc-title"><span class="dc-dot" style="background:#c084fc"></span> Zero Lock-in</div>
                    <div class="dc-detail">Standard protocols (STAC, ERDDAP, OPeNDAP) mean this COP can be rebuilt against any compatible federation</div>
                </div>
            </div>

            <h3>AQUAVIEW API</h3>
            <p style="font-family:'JetBrains Mono',monospace;font-size:11px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:10px 14px;color:#38bdf8;word-break:break-all">
                https://aquaview-sfeos-1025757962819.us-east1.run.app/collections
            </p>
            <p style="margin-top:8px">Query any collection, filter by bounding box and time, and follow <code>aquaview:source_url</code> links to get live data from the original providers.</p>
        </div>

        <div class="about-content tab-pane" id="tab-overview">
            <h2>Gulf Ocean Intelligence COP</h2>
            <p>The <span class="hl">ultimate Common Operating Picture</span> for the Gulf of Mexico â€” bringing together <span class="hl">22 real-time layers</span> across 9 AQUAVIEW data collections into a single visualization. Surface currents, satellite imagery, thousands of in-situ sensors, glider missions, oil spill alerts, and weather observations â€” all discovered through AQUAVIEW's federated ocean data infrastructure.</p>
            <h3>What you're seeing</h3>
            <p>Animated particles trace <span class="hl">ocean surface currents</span> from satellite altimetry. IDW-interpolated heatmaps show continuous temperature and dissolved oxygen fields from hundreds of sensors. Overlaid: ~500 IOOS sensors, 313 NDBC buoys, 140 CO-OPS tidal stations, 5 USF glider missions with real ERDDAP tracks, pollution incidents, and hurricane monitoring probes.</p>
            <h3>Why it matters</h3>
            <p>The Gulf of Mexico hosts the Western Hemisphere's largest recurring <span class="hl">hypoxic dead zone</span>. By fusing real-time data from every available source through AQUAVIEW, this COP enables early warning of hypoxic events, oil spill tracking, hurricane monitoring, and ecosystem-scale situational awareness.</p>
            <h3>Default View</h3>
            <p>The COP opens with an operational baseline: <span class="hl">sea surface temperature</span> and <span class="hl">dissolved oxygen</span> heatmaps showing water conditions, <span class="hl">current flow</span> particles showing circulation, and <span class="hl">active glider tracks</span> showing real-time sampling missions. Toggle additional layers from the panel on the right.</p>
        </div>

        <div class="about-content tab-pane" id="tab-layers">
            <h2>Data Layers â€” 22 layers across 9 collections</h2>
            <p>All data discovered through the AQUAVIEW STAC API, pre-fetched server-side every 2 hours via GitHub Actions.</p>
            <div class="data-grid">
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#38bdf8"></span> Surface Currents</div><div class="dc-detail">CoastWatch Blended NRT â€¢ 0.25Â° grid daily â€¢ 5,000 particles with bilinear interpolation</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#22c55e"></span> Chlorophyll-a</div><div class="dc-detail">Sentinel-3B OLCI â€¢ 300m daily â€¢ Phytoplankton / HAB indicator</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#f97316"></span> Sea Surface Temp</div><div class="dc-detail">VIIRS ACSPO â€¢ 750m daily â€¢ Thermal stratification context</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#818cf8"></span> Sea Surface Salinity</div><div class="dc-detail">SMOS L3 â€¢ 0.25Â° daily â€¢ Freshwater plumes / river outflow</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#facc15"></span> NDBC Hypoxia</div><div class="dc-detail">58 stations â€¢ DO, temp, sal, pH â€¢ TimesFM + XGBoost predictions</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#fbbf24"></span> NDBC Weather Buoys</div><div class="dc-detail">~313 buoys from AQUAVIEW NDBC collection â€¢ Wind, waves, SST, pressure</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#fb7185"></span> CO-OPS Tidal</div><div class="dc-detail">~140 stations from AQUAVIEW COOPS â€¢ Water level, tidal predictions</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#2dd4bf"></span> IOOS Sensors</div><div class="dc-detail">~500 from AQUAVIEW IOOS_SENSORS â€¢ Temp, sal, chl, DO, nutrients</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#ef4444"></span> Oil Spills</div><div class="dc-detail">AQUAVIEW INCIDENT_NEWS â€¢ ~110 Gulf incidents, last 2 years</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#c084fc"></span> Gliders</div><div class="dc-detail">AQUAVIEW IOOS collection â€¢ ~51 active/recent Gulf missions</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#f472b6"></span> PMEL Probes</div><div class="dc-detail">AQUAVIEW PMEL collection â€¢ Hurricane monitoring Oshen floats</div></div>
                <div class="data-card"><div class="dc-title"><span class="dc-dot" style="background:#94a3b8"></span> Weather</div><div class="dc-detail">Wind barbs + wave height from NDBC met data â€¢ Standard meteorological notation</div></div>
            </div>
        </div>

        <div class="about-content tab-pane" id="tab-tech">
            <h2>Technical Architecture</h2>
            <h3>AQUAVIEW STAC Discovery</h3>
            <p>Every 6 hours, a Python script queries the <span class="hl">AQUAVIEW STAC API</span> with a Gulf bounding box filter across 7+ collections. Each STAC item includes <code>aquaview:source_url</code> pointing to the original ERDDAP server, plus <code>aquaview:variables</code> listing available parameters. The script fetches latest readings from each source and writes static JSON files to <code>docs/data/</code>, bypassing browser CORS restrictions.</p>
            <h3>Particle System</h3>
            <p>5,000 particles with 120-frame lifetime, bilinear velocity interpolation, speed-proportional line width and color, and alpha-fade trails (0.975 opacity per frame). Zoom-responsive scaling maintains visual coherence from zoom 4 to 12.</p>
            <h3>Stack</h3>
            <p>
                <span class="tag" style="background:rgba(56,189,248,0.15);color:#38bdf8">Leaflet 1.9</span>
                <span class="tag" style="background:rgba(34,197,94,0.15);color:#22c55e">HTML5 Canvas</span>
                <span class="tag" style="background:rgba(167,139,250,0.15);color:#a78bfa">AQUAVIEW STAC</span>
                <span class="tag" style="background:rgba(249,115,22,0.15);color:#f97316">CoastWatch WMS</span>
                <span class="tag" style="background:rgba(250,204,21,0.15);color:#facc15">NDBC Realtime</span>
                <span class="tag" style="background:rgba(251,113,133,0.15);color:#fb7185">CO-OPS API</span>
                <span class="tag" style="background:rgba(45,212,191,0.15);color:#2dd4bf">IOOS ERDDAP</span>
                <span class="tag" style="background:rgba(239,68,68,0.15);color:#ef4444">GitHub Actions</span>
            </p>
        </div>

        <div class="about-content tab-pane" id="tab-models">
            <h2>Machine Learning Models</h2>
            <p>The NDBC hypoxia stations (yellow markers) are paired with ML models forecasting <span class="hl">dissolved oxygen dropping below 2.0 mg/L</span> at 1, 3, 5, and 7-day lead times.</p>
            <h3>TimesFM (Google Foundation Model)</h3>
            <p>200M-parameter zero-shot time series forecaster. Ingests ~512 hours of DO observations and produces probabilistic forecasts blending quantile crossings (60%) and point forecast hours below threshold (40%).</p>
            <h3>XGBoost Baseline</h3>
            <p>Traditional ML baseline with engineered features: rolling statistics, temporal features, tidal harmonics, and change-point detection. Trained per-station with temporal splits.</p>
            <h3>Live Pipeline</h3>
            <p>Every 6 hours: fetch ~45 days of DO data from NDBC, preprocess, run TimesFM on CPU, and update prediction JSON. Stations without active sensors use a statistical estimator.</p>
        </div>
    </div>
</div>

<div class="loading-overlay" id="loading">
    <h1 style="font-size: 22px; font-weight: 300; letter-spacing: 0.05em; color: #e0e6f0">
        AQUAVIEW <span style="font-weight: 700">Ocean Intelligence</span>
    </h1>
    <div class="loading-text" id="loading-text">Initializing ultimate COP...</div>
    <div class="loading-bar"><div class="fill"></div></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PARTICLE_COUNT = 1500;
const PARTICLE_LIFETIME = 80;
const PARTICLE_LINE_WIDTH = 0.8;
const SPEED_SCALE = 0.0004;
const FADE_OPACITY = 0.88;
const GULF_BOUNDS = { latMin: 18, latMax: 32, lonMin: -98, lonMax: -80 };
const CURRENT_URL_LOCAL = 'data/currents.json?t=' + Date.now();
const CURRENT_URL_LIVE = 'https://coastwatch.noaa.gov/erddap/griddap/noaacwBLENDEDNRTcurrentsDaily.json?u_current[(last)][(18):(32)][(-98):(-80)],v_current[(last)][(18):(32)][(-98):(-80)]';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let map, canvas, ctx, windCanvas, windCtx, heatCanvas, heatCtx;
let currentGrid = null;
let particles = [];
let animRunning = true;
let layerState = {
    currents: true, ssh: false,
    sst_heat: true, water_level: false, do_field: true,
    chlorophyll: false, sst: false, salinity: false, kd490: false,
    ndbc_met: false, ioos: false,
    incidents: false, pmel: false,
    glider_bass: true, glider_gansett: false, glider_jaialai: true, glider_sam: false, glider_stella: true,
    wind: false, waves: false
};
// Internal: ndbc layer always loads (feeds DO field) but has no separate toggle
let leafletLayers = {};
let totalSensors = 0;
let ndbcMetData = null;  // Cache for wind/wave rendering

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleAbout() { document.getElementById('about-overlay').classList.toggle('visible'); }
window.toggleAbout = toggleAbout;

function switchTab(name) {
    document.querySelectorAll('.about-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-pane').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById('tab-' + name).classList.add('active');
}
window.switchTab = switchTab;

function toggleGroup(id) {
    const body = document.getElementById('grp-' + id);
    const chev = document.getElementById('chevron-' + id);
    body.classList.toggle('collapsed');
    chev.classList.toggle('collapsed');
}
window.toggleGroup = toggleGroup;

function setLoadingText(text) { document.getElementById('loading-text').textContent = text; }

function setCount(id, n) {
    const el = document.getElementById(id);
    if (el) el.textContent = typeof n === 'number' ? n.toLocaleString() : n;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAP SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initMap() {
    map = L.map('map', { center: [26.5, -89], zoom: 5, minZoom: 4, maxZoom: 12, zoomControl: false, attributionControl: true });
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a> | <a href="https://aquaview-sfeos-1025757962819.us-east1.run.app">AQUAVIEW</a>, NOAA',
        maxZoom: 19,
    }).addTo(map);

    // â”€â”€â”€ WMS Satellite Layers â”€â”€â”€
    leafletLayers.chlorophyll = L.tileLayer.wms('https://coastwatch.noaa.gov/erddap/wms/noaacwS3BOLCIchlaDaily/request?', {
        layers: 'noaacwS3BOLCIchlaDaily:chlor_a', format: 'image/png', transparent: true, opacity: 0.4,
        styles: 'rainbow~Log', colorBarMin: 0.01, colorBarMax: 30,
    });
    leafletLayers.sst = L.tileLayer.wms('https://coastwatch.noaa.gov/erddap/wms/noaacwSNPPACSPOSSTL3GCDaily/request?', {
        layers: 'noaacwSNPPACSPOSSTL3GCDaily:sea_surface_temperature', format: 'image/png', transparent: true, opacity: 0.4,
        styles: 'rainbow~Linear', colorBarMin: 10, colorBarMax: 32,
    });
    leafletLayers.ssh = L.tileLayer.wms('https://coastwatch.noaa.gov/erddap/wms/noaacwBLENDEDsshDaily/request?', {
        layers: 'noaacwBLENDEDsshDaily:sla', format: 'image/png', transparent: true, opacity: 0.35,
        styles: 'rainbow~Linear', colorBarMin: -0.5, colorBarMax: 0.5,
    });
    leafletLayers.salinity = L.tileLayer.wms('https://coastwatch.noaa.gov/erddap/wms/noaacwSMOSsssDaily/request?', {
        layers: 'noaacwSMOSsssDaily:sss', format: 'image/png', transparent: true, opacity: 0.4,
        styles: 'rainbow~Linear', colorBarMin: 30, colorBarMax: 38,
    });
    leafletLayers.kd490 = L.tileLayer.wms('https://coastwatch.noaa.gov/erddap/wms/noaacwNPPVIIRSkd490Daily/request?', {
        layers: 'noaacwNPPVIIRSkd490Daily:kd_490', format: 'image/png', transparent: true, opacity: 0.4,
        styles: 'rainbow~Log', colorBarMin: 0.01, colorBarMax: 5,
    });

    if (layerState.chlorophyll) leafletLayers.chlorophyll.addTo(map);

    // Canvas
    canvas = document.getElementById('current-canvas');
    ctx = canvas.getContext('2d');
    heatCanvas = document.getElementById('heat-canvas');
    heatCtx = heatCanvas.getContext('2d');
    windCanvas = document.getElementById('wind-canvas');
    windCtx = windCanvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    map.on('move zoom moveend zoomend', () => {
        clearCanvas(); renderHeatmaps(); renderWindBarbs(); renderWaveCircles();
        // Show DO labels only at zoom >= 8
        const mc = document.querySelector('.leaflet-map-pane');
        if (mc) { if (map.getZoom() < 8) mc.classList.add('hide-do-labels'); else mc.classList.remove('hide-do-labels'); }
    });
}

function resizeCanvas() {
    canvas.width = heatCanvas.width = windCanvas.width = window.innerWidth;
    canvas.height = heatCanvas.height = windCanvas.height = window.innerHeight;
}
function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OCEAN CURRENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchCurrents() {
    setLoadingText('Downloading ocean current vectors...');
    try {
        let json;
        try {
            const localResp = await fetch(CURRENT_URL_LOCAL);
            if (localResp.ok) json = await localResp.json();
        } catch(e) {}
        if (!json) {
            const liveResp = await fetch(CURRENT_URL_LIVE);
            if (!liveResp.ok) throw new Error(`HTTP ${liveResp.status}`);
            json = await liveResp.json();
        }
        const table = json.table, rows = table.rows;
        const latSet = new Set(), lonSet = new Set();
        rows.forEach(r => { latSet.add(r[1]); lonSet.add(r[2]); });
        const lats = [...latSet].sort((a,b) => a - b);
        const lons = [...lonSet].sort((a,b) => a - b);
        const nLat = lats.length, nLon = lons.length;
        const u = Array.from({length: nLat}, () => new Float32Array(nLon));
        const v = Array.from({length: nLat}, () => new Float32Array(nLon));
        const latIdx = {}, lonIdx = {};
        lats.forEach((l,i) => latIdx[l] = i); lons.forEach((l,i) => lonIdx[l] = i);
        let validCount = 0;
        rows.forEach(r => {
            const li = latIdx[r[1]], lo = lonIdx[r[2]];
            if (li !== undefined && lo !== undefined && r[3] != null && r[4] != null) {
                u[li][lo] = r[3]; v[li][lo] = r[4]; validCount++;
            }
        });
        currentGrid = { lats, lons, u, v, nLat, nLon };
        setCount('currents-status', validCount + ' pts');
        return true;
    } catch (e) {
        console.error('Current fetch failed:', e);
        setCount('currents-status', 'offline');
        return false;
    }
}

function interpolateCurrent(lat, lon) {
    if (!currentGrid) return [0, 0];
    const g = currentGrid;
    const latStep = g.lats[1] - g.lats[0], lonStep = g.lons[1] - g.lons[0];
    const li = (lat - g.lats[0]) / latStep, lo = (lon - g.lons[0]) / lonStep;
    const li0 = Math.floor(li), lo0 = Math.floor(lo);
    if (li0 < 0 || li0 >= g.nLat - 1 || lo0 < 0 || lo0 >= g.nLon - 1) return [0, 0];
    const fLat = li - li0, fLon = lo - lo0;
    const u00 = g.u[li0][lo0], u10 = g.u[li0+1][lo0], u01 = g.u[li0][lo0+1], u11 = g.u[li0+1][lo0+1];
    const v00 = g.v[li0][lo0], v10 = g.v[li0+1][lo0], v01 = g.v[li0][lo0+1], v11 = g.v[li0+1][lo0+1];
    if (!u00 && !u10 && !u01 && !u11) return [0, 0];
    return [
        (1-fLat)*(1-fLon)*u00 + fLat*(1-fLon)*u10 + (1-fLat)*fLon*u01 + fLat*fLon*u11,
        (1-fLat)*(1-fLon)*v00 + fLat*(1-fLon)*v10 + (1-fLat)*fLon*v01 + fLat*fLon*v11
    ];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARTICLE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initParticles() {
    particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(spawnParticle());
    setCount('stat-particles', PARTICLE_COUNT.toLocaleString());
}
function spawnParticle() {
    const b = map.getBounds();
    return { lat: b.getSouth() + Math.random() * (b.getNorth() - b.getSouth()),
             lon: b.getWest() + Math.random() * (b.getEast() - b.getWest()),
             age: Math.floor(Math.random() * PARTICLE_LIFETIME), prevX: null, prevY: null };
}
function speedColor(speed) {
    const t = Math.min(speed / 0.5, 1);
    if (t < 0.25) { const s = t/0.25; return `rgba(${60+100*s},${100+120*s},${160+90*s},0.25)`; }
    else if (t < 0.5) { const s = (t-0.25)/0.25; return `rgba(${160-30*s},220,${250-10*s},0.30)`; }
    else if (t < 0.75) { const s = (t-0.5)/0.25; return `rgba(${130+120*s},${220-80*s},${240-100*s},0.35)`; }
    else { const s = (t-0.75)/0.25; return `rgba(250,${140+60*s},${140-80*s},0.45)`; }
}
function animateParticles() {
    if (!animRunning || !layerState.currents || !currentGrid) { requestAnimationFrame(animateParticles); return; }
    ctx.globalCompositeOperation = 'destination-in';
    ctx.fillStyle = `rgba(0,0,0,${FADE_OPACITY})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    const zoom = map.getZoom(), speedMult = SPEED_SCALE * Math.pow(2, 8 - zoom);
    const zoomScale = Math.max(1, (zoom - 3) * 0.5), lineWidth = PARTICLE_LINE_WIDTH * zoomScale;
    for (let i = 0; i < particles.length; i++) {
        const p = particles[i]; p.age++;
        if (p.age > PARTICLE_LIFETIME) { particles[i] = spawnParticle(); continue; }
        const [u, v] = interpolateCurrent(p.lat, p.lon);
        const speed = Math.sqrt(u*u + v*v);
        if (speed < 0.001) { particles[i] = spawnParticle(); continue; }
        const newLon = p.lon + u * speedMult, newLat = p.lat + v * speedMult;
        const pt = map.latLngToContainerPoint([newLat, newLon]);
        if (p.prevX !== null) {
            ctx.beginPath(); ctx.moveTo(p.prevX, p.prevY); ctx.lineTo(pt.x, pt.y);
            ctx.strokeStyle = speedColor(speed); ctx.lineWidth = lineWidth + speed * 1;
            ctx.lineCap = 'round'; ctx.stroke();
        }
        p.prevX = pt.x; p.prevY = pt.y; p.lat = newLat; p.lon = newLon;
        const b = map.getBounds();
        if (newLat < b.getSouth() || newLat > b.getNorth() || newLon < b.getWest() || newLon > b.getEast()) particles[i] = spawnParticle();
    }
    requestAnimationFrame(animateParticles);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SENSOR LAYERS â€” All from pre-fetched static JSON
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- NDBC Hypoxia (existing latest.json) ---
async function loadNDBCHypoxia() {
    setLoadingText('Loading NDBC hypoxia stations...');
    try {
        let data;
        try { const r = await fetch('data/latest.json?t=' + Date.now()); if (r.ok) data = await r.json(); } catch(e) {}
        if (!data && typeof EMBEDDED_LATEST !== 'undefined') data = EMBEDDED_LATEST;
        if (!data) return 0;
        if (data.updated) {
            const d = new Date(data.updated), ago = Math.round((Date.now() - d.getTime()) / 3600000);
            const agoStr = ago < 1 ? 'just now' : ago < 24 ? ago + 'h ago' : Math.round(ago/24) + 'd ago';
            setCount('stat-updated', agoStr);
            document.getElementById('stat-updated').title = 'Data: ' + d.toUTCString();
        }
        const group = L.layerGroup(); let count = 0;
        data.stations.forEach(s => {
            if (!s.lat || !s.lon) return; count++;
            const hasModel = s.has_model, hasDO = s.current && s.current.do != null;
            const temp = s.current && s.current.temp != null ? s.current.temp.toFixed(1) + 'Â°C' : 'â€”';
            const sal = s.current && s.current.sal != null ? s.current.sal.toFixed(1) + ' psu' : 'â€”';
            const doVal = hasDO ? s.current.do.toFixed(2) + ' mg/L' : 'â€”';
            // Data-driven color: red=hypoxic(<2), orange=stressed(2-4), yellow=watch(4-6), green=ok(>6)
            const color = hasDO && s.current.do <= 2 ? '#ef4444' : hasDO && s.current.do <= 4 ? '#f59e0b' : hasDO && s.current.do <= 6 ? '#facc15' : hasDO ? '#22c55e' : hasModel ? '#a78bfa' : '#64748b';
            // Data-driven size: bigger markers for low-DO (high risk) stations
            const radius = hasDO && s.current.do <= 2 ? 12 : hasDO && s.current.do <= 4 ? 10 : hasModel ? 7 : 5;
            const weight = hasDO && s.current.do <= 4 ? 2.5 : hasModel ? 2 : 1;
            const marker = L.circleMarker([s.lat, s.lon], { radius, color, fillColor: color, fillOpacity: hasDO ? 0.85 : 0.5, weight }).addTo(group);
            // Add DO value label as a tooltip visible at zoom >= 8
            if (hasDO) {
                marker.bindTooltip(s.current.do.toFixed(1), {
                    permanent: true, direction: 'center', className: 'do-label',
                    offset: [0, -14]
                });
            }
            const engine = s.model_type === 'timesfm' ? '<span style="color:#c084fc">TimesFM</span>' : s.model_type === 'xgboost' ? '<span style="color:#60a5fa">XGBoost</span>' : '';
            let predHTML = '';
            if (s.predictions && Object.keys(s.predictions).length > 0) {
                predHTML = '<div style="margin-top:8px;padding-top:6px;border-top:1px solid rgba(255,255,255,0.08)">';
                for (const [lead, p] of Object.entries(s.predictions)) {
                    const pct = (p.prob * 100).toFixed(0);
                    const rc = p.risk === 'high' ? '#ef4444' : p.risk === 'moderate' ? '#f59e0b' : '#22c55e';
                    predHTML += `<div style="font-size:11px;margin-top:3px">${lead}: <span style="color:${rc};font-weight:600">${pct}%</span> <span style="color:#64748b">(${p.engine || s.model_type || ''})</span></div>`;
                }
                predHTML += '</div>';
            }
            marker.bindPopup(`<div style="font-weight:600;font-size:14px;margin-bottom:4px">${s.id} ${engine}</div>
                <div style="color:#94a3b8;font-size:11px;margin-bottom:8px">${s.name || ''}</div>
                <div style="font-family:'JetBrains Mono',monospace;font-size:12px;line-height:1.8">
                Temp: <span style="color:#38bdf8">${temp}</span><br>Sal: ${sal}<br>
                DO: <span style="color:${hasDO && s.current.do <= 2 ? '#ef4444' : '#22c55e'}">${doVal}</span></div>${predHTML}`);
        });
        leafletLayers.ndbc = group;
        if (layerState.do_field) group.addTo(map);  // DO field shows hypoxia markers
        // Feed unified data arrays
        data.stations.forEach(s => {
            if (!s.lat || !s.lon || !s.current) return;
            if (s.current.temp != null) allTempPoints.push({ lat: s.lat, lon: s.lon, val: s.current.temp });
            if (s.current.do != null) allDOPoints.push({ lat: s.lat, lon: s.lon, val: s.current.do });
        });
        setCount('do-count', allDOPoints.length + ' pts');
        totalSensors += count;
        return count;
    } catch (e) { console.error('NDBC hypoxia load failed:', e); return 0; }
}

// --- NDBC Weather Buoys (from AQUAVIEW via ndbc_met.json) ---
async function loadNDBCMet() {
    setLoadingText('Loading NDBC weather buoys...');
    try {
        const r = await fetch('data/ndbc_met.json?t=' + Date.now());
        if (!r.ok) return 0;
        const data = await r.json();
        ndbcMetData = data;  // Cache for wind barbs
        const group = L.layerGroup(); let count = 0;
        (data.buoys || []).forEach(b => {
            if (!b.lat || !b.lon) return; count++;
            const c = b.current || {};
            // Color by SST: cool blue â†’ warm orange â†’ hot red
            const hasSST = c.wtmp != null;
            const sstColor = hasSST ? (c.wtmp < 18 ? '#3b82f6' : c.wtmp < 22 ? '#38bdf8' : c.wtmp < 26 ? '#fbbf24' : c.wtmp < 29 ? '#f97316' : '#ef4444') : '#fbbf24';
            // Size by wind speed
            const hasWind = c.wspd != null;
            const wRadius = hasWind ? 4 + Math.min(c.wspd * 0.4, 5) : 4;
            const marker = L.circleMarker([b.lat, b.lon], {
                radius: wRadius, color: sstColor, fillColor: sstColor, fillOpacity: hasSST ? 0.7 : 0.4, weight: 1
            }).addTo(group);
            const wspd = c.wspd != null ? c.wspd.toFixed(1) + ' m/s' : 'â€”';
            const wdir = c.wdir != null ? c.wdir + 'Â°' : 'â€”';
            const wvht = c.wvht != null ? c.wvht.toFixed(1) + ' m' : 'â€”';
            const wtmp = c.wtmp != null ? c.wtmp.toFixed(1) + 'Â°C' : 'â€”';
            const pres = c.pres != null ? c.pres.toFixed(1) + ' hPa' : 'â€”';
            marker.bindPopup(`<div style="font-weight:600;font-size:13px">${b.title || b.id}</div>
                <div style="color:#94a3b8;font-size:11px;margin-bottom:6px">NDBC ${b.id}</div>
                <div style="font-family:'JetBrains Mono',monospace;font-size:11px;line-height:1.7">
                Wind: <span style="color:#fbbf24">${wspd}</span> @ ${wdir}<br>
                Waves: <span style="color:#60a5fa">${wvht}</span><br>
                SST: <span style="color:#f97316">${wtmp}</span><br>
                Pressure: ${pres}</div>
                <div style="color:#64748b;font-size:10px;margin-top:4px">Vars: ${(b.vars||[]).slice(0,5).join(', ')}</div>`);
        });
        leafletLayers.ndbc_met = group;
        if (layerState.ndbc_met) group.addTo(map);
        // Feed unified temp array from SST data
        (data.buoys || []).forEach(b => {
            if (b.lat && b.lon && (b.current || {}).wtmp != null)
                allTempPoints.push({ lat: b.lat, lon: b.lon, val: b.current.wtmp });
        });
        setCount('sst-heat-count', allTempPoints.length + ' pts');
        setCount('ndbc-met-count', count); totalSensors += count;
        return count;
    } catch (e) { console.error('NDBC met load failed:', e); return 0; }
}

// --- CO-OPS Tidal Stations (from AQUAVIEW via coops.json) ---
async function loadCOOPS() {
    setLoadingText('Loading CO-OPS tidal stations...');
    try {
        const r = await fetch('data/coops.json?t=' + Date.now());
        if (!r.ok) return 0;
        const data = await r.json();
        const group = L.layerGroup(); let count = 0;
        (data.stations || []).forEach(s => {
            if (!s.lat || !s.lon) return; count++;
            const hasWL = s.current && s.current.wl != null;
            const wl = hasWL ? s.current.wl : 0;
            // Color by water level: deep blue (low) â†’ cyan (mid) â†’ orange (high tide)
            const wlColor = hasWL ? (wl < -0.3 ? '#3b82f6' : wl < 0 ? '#38bdf8' : wl < 0.3 ? '#06b6d4' : wl < 0.6 ? '#f59e0b' : '#ef4444') : '#fb7185';
            const radius = hasWL ? 5 + Math.min(Math.abs(wl) * 6, 5) : 4;
            const marker = L.circleMarker([s.lat, s.lon], {
                radius, color: wlColor, fillColor: wlColor, fillOpacity: hasWL ? 0.75 : 0.4, weight: 1.5
            }).addTo(group);
            const wlStr = hasWL ? wl.toFixed(2) + ' m' : 'â€”';
            marker.bindPopup(`<div style="font-weight:600;font-size:13px">${s.title || s.id}</div>
                <div style="color:#94a3b8;font-size:11px">CO-OPS ${s.id}</div>
                <div style="font-family:'JetBrains Mono',monospace;font-size:12px;margin-top:6px">Water Level: <span style="color:${wlColor}">${wlStr}</span> MLLW</div>
                <div style="color:#64748b;font-size:10px;margin-top:4px">Vars: ${(s.vars||[]).slice(0,4).join(', ')}</div>`);
        });
        leafletLayers.coops = group;
        if (layerState.water_level) group.addTo(map);  // Water level shows CO-OPS markers
        // Feed unified water level array
        (data.stations || []).forEach(s => {
            if (s.lat && s.lon && (s.current || {}).wl != null)
                allWLPoints.push({ lat: s.lat, lon: s.lon, val: s.current.wl });
        });
        setCount('wl-count', allWLPoints.length + ' pts');
        totalSensors += count;
        return count;
    } catch (e) { console.error('CO-OPS load failed:', e); return 0; }
}

// --- IOOS Sensor Network (from AQUAVIEW via ioos_sensors.json) ---
async function loadIOOS() {
    setLoadingText('Loading IOOS sensor network...');
    try {
        const r = await fetch('data/ioos_sensors.json?t=' + Date.now());
        if (!r.ok) return 0;
        const data = await r.json();
        const group = L.layerGroup(); let count = 0;
        (data.sensors || []).forEach(s => {
            if (!s.lat || !s.lon) return; count++;
            const marker = L.circleMarker([s.lat, s.lon], {
                radius: 3, color: '#2dd4bf', fillColor: '#2dd4bf', fillOpacity: 0.4, weight: 0.8
            }).addTo(group);
            marker.bindPopup(`<div style="font-weight:600;font-size:13px">${s.title || s.id}</div>
                <div style="color:#94a3b8;font-size:11px;margin-bottom:4px">${s.org || 'IOOS'}</div>
                <div style="color:#2dd4bf;font-size:11px">Variables: ${(s.vars||[]).slice(0,6).join(', ')}</div>`);
        });
        leafletLayers.ioos = group;
        if (layerState.ioos) group.addTo(map);
        setCount('ioos-count', count); totalSensors += count;
        return count;
    } catch (e) { console.error('IOOS load failed:', e); return 0; }
}

// --- Glider Tracks (from AQUAVIEW via gliders.json) ---
async function loadGliders() {
    setLoadingText('Loading glider missions...');
    try {
        const r = await fetch('data/gliders.json?t=' + Date.now());
        if (!r.ok) return 0;
        const data = await r.json();
        let totalCount = 0;

        // Map of glider short name â†’ { layerKey, color, countId }
        const gliderMeta = {
            'usf-bass':    { key: 'glider_bass',    color: '#c084fc', countId: 'glider-bass-count' },
            'usf-gansett': { key: 'glider_gansett',  color: '#60a5fa', countId: 'glider-gansett-count' },
            'usf-jaialai': { key: 'glider_jaialai',  color: '#f472b6', countId: 'glider-jaialai-count' },
            'usf-sam':     { key: 'glider_sam',      color: '#fb923c', countId: 'glider-sam-count' },
            'usf-stella':  { key: 'glider_stella',   color: '#34d399', countId: 'glider-stella-count' }
        };

        function getGliderName(id) {
            const parts = id.split('-');
            for (let i = parts.length - 1; i >= 1; i--) {
                if (/^\d/.test(parts[i])) continue;
                return parts.slice(0, i + 1).join('-');
            }
            return parts[0];
        }

        // Group deployments by glider
        const byGlider = {};
        (data.gliders || []).forEach(g => {
            if (!g.track || g.track.length === 0) return;
            const name = getGliderName(g.id);
            if (!byGlider[name]) byGlider[name] = [];
            byGlider[name].push(g);
        });

        // Create a separate layer group for each glider
        Object.entries(byGlider).forEach(([name, deployments]) => {
            const meta = gliderMeta[name];
            if (!meta) return; // Unknown glider, skip
            const color = meta.color;
            const displayName = name.replace('usf-', '').toUpperCase();
            const group = L.layerGroup();
            let count = 0;

            deployments.sort((a, b) => (a.start || '').localeCompare(b.start || ''));

            // Connect multiple deployments with dashed line
            if (deployments.length > 1) {
                const allPts = deployments.map(g => {
                    const c = g.track[g.track.length - 1];
                    return [c[1], c[0]];
                });
                L.polyline(allPts, { color, weight: 2.5, opacity: 0.5, dashArray: '8 4' }).addTo(group);
            }

            deployments.forEach((g, di) => {
                count++;
                const latLngs = g.track.map(c => [c[1], c[0]]);
                if (latLngs.length > 1) {
                    L.polyline(latLngs, { color, weight: 2, opacity: 0.7 }).addTo(group);
                }
                const last = latLngs[latLngs.length - 1];
                const isLatest = di === deployments.length - 1;
                L.circleMarker(last, {
                    radius: isLatest ? 8 : 4,
                    color, fillColor: color,
                    fillOpacity: isLatest ? 1 : 0.5,
                    weight: isLatest ? 2.5 : 1
                }).addTo(group).bindPopup(`<div style="font-weight:700;color:${color};font-size:14px">\u{1F93F} ${displayName}</div>
                    <div style="color:#e0e6f0;font-size:12px;margin:4px 0">${g.title || g.id}</div>
                    <div style="color:#94a3b8;font-size:11px">${g.start ? g.start.slice(0,10) : ''}${g.end ? ' \u2192 ' + g.end.slice(0,10) : ''}</div>
                    <div style="color:#64748b;font-size:10px;margin-top:4px">Deployment ${di + 1} of ${deployments.length}</div>
                    <div style="color:#64748b;font-size:10px">Track: ${g.track.length} pts</div>`);
            });

            leafletLayers[meta.key] = group;
            if (layerState[meta.key]) group.addTo(map);
            setCount(meta.countId, count);
            totalCount += count;
        });

        return totalCount;
    } catch (e) { console.error('Gliders load failed:', e); return 0; }
}

// --- Incidents (from AQUAVIEW via incidents.json) ---
async function loadIncidents() {
    setLoadingText('Loading incident reports...');
    try {
        const r = await fetch('data/incidents.json?t=' + Date.now());
        if (!r.ok) return 0;
        const data = await r.json();
        const group = L.layerGroup(); let count = 0;
        (data.incidents || []).forEach(inc => {
            if (!inc.lat || !inc.lon) return; count++;
            const daysAgo = inc.date ? Math.round((Date.now() - new Date(inc.date).getTime()) / 86400000) : null;
            const opacity = daysAgo != null && daysAgo < 30 ? 0.9 : daysAgo != null && daysAgo < 180 ? 0.6 : 0.35;
            const radius = daysAgo != null && daysAgo < 30 ? 8 : daysAgo != null && daysAgo < 180 ? 6 : 4;

            // Triangle-ish marker using DivIcon
            const marker = L.circleMarker([inc.lat, inc.lon], {
                radius, color: '#ef4444', fillColor: '#ef4444', fillOpacity: opacity, weight: 1.5
            }).addTo(group);

            const dateStr = inc.date ? new Date(inc.date).toLocaleDateString() : 'Unknown date';
            marker.bindPopup(`<div style="font-weight:600;font-size:13px;color:#ef4444">âš  ${inc.title || 'Incident'}</div>
                <div style="color:#94a3b8;font-size:11px;margin-bottom:6px">${dateStr}${daysAgo != null ? ' (' + daysAgo + 'd ago)' : ''}</div>
                <div style="font-size:12px;color:#cbd5e1;line-height:1.5">${inc.desc || ''}</div>
                ${inc.url ? '<div style="margin-top:6px"><a href="' + inc.url + '" target="_blank" style="color:#38bdf8;font-size:11px">View details â†’</a></div>' : ''}`);
        });
        leafletLayers.incidents = group;
        if (layerState.incidents) group.addTo(map);
        setCount('incidents-count', count);
        return count;
    } catch (e) { console.error('Incidents load failed:', e); return 0; }
}

// --- PMEL Hurricane Probes ---
async function loadPMEL() {
    try {
        const r = await fetch('data/pmel.json?t=' + Date.now());
        if (!r.ok) return 0;
        const data = await r.json();
        const group = L.layerGroup(); let count = 0;
        (data.probes || []).forEach(p => {
            if (!p.lat || !p.lon) return; count++;
            const marker = L.circleMarker([p.lat, p.lon], {
                radius: 6, color: '#f472b6', fillColor: '#f472b6', fillOpacity: 0.7, weight: 1.5
            }).addTo(group);
            marker.bindPopup(`<div style="font-weight:600;font-size:13px;color:#f472b6">${p.title || p.id}</div>
                <div style="color:#94a3b8;font-size:11px">${p.date ? new Date(p.date).toLocaleDateString() : ''}</div>
                <div style="color:#64748b;font-size:10px;margin-top:4px">Vars: ${(p.vars||[]).join(', ')}</div>`);
        });
        leafletLayers.pmel = group;
        if (layerState.pmel) group.addTo(map);
        setCount('pmel-count', count);
        return count;
    } catch (e) { console.error('PMEL load failed:', e); return 0; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNIFIED IDW HEATMAP RENDERER (for any variable)
// Merges data across all sources into spatial fields
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let allTempPoints = [];   // {lat,lon,val} from NDBC hypoxia + NDBC met
let allDOPoints = [];     // {lat,lon,val} from NDBC hypoxia
let allWLPoints = [];     // {lat,lon,val} from CO-OPS

function idwColormap(val, vmin, vmax, scheme) {
    const t = Math.max(0, Math.min(1, (val - vmin) / (vmax - vmin)));
    let r, g, b;
    if (scheme === 'thermal') {
        // Cool blue â†’ cyan â†’ yellow â†’ orange â†’ red
        if (t < 0.2)      { const s=t/0.2;     r=30+50*s;   g=50+120*s;  b=180+50*s; }
        else if (t < 0.4) { const s=(t-0.2)/0.2; r=80-30*s;  g=170+50*s;  b=230-150*s; }
        else if (t < 0.6) { const s=(t-0.4)/0.2; r=50+180*s; g=220;       b=80-60*s; }
        else if (t < 0.8) { const s=(t-0.6)/0.2; r=230+20*s; g=220-100*s; b=20-10*s; }
        else               { const s=(t-0.8)/0.2; r=250;      g=120-70*s;  b=10+20*s; }
    } else if (scheme === 'oxygen') {
        // Red (hypoxic) â†’ orange â†’ yellow â†’ green (healthy)
        if (t < 0.25)      { const s=t/0.25;     r=220;       g=40+60*s;   b=40; }
        else if (t < 0.5)  { const s=(t-0.25)/0.25; r=220+30*s; g=100+80*s;  b=40; }
        else if (t < 0.75) { const s=(t-0.5)/0.25; r=250-120*s; g=180+40*s;  b=40+30*s; }
        else                { const s=(t-0.75)/0.25; r=130-80*s;  g=220;       b=70+50*s; }
    } else if (scheme === 'tidal') {
        // Deep blue â†’ cyan â†’ white â†’ amber
        if (t < 0.3)      { const s=t/0.3;     r=20+30*s;   g=60+100*s;  b=180+40*s; }
        else if (t < 0.5) { const s=(t-0.3)/0.2; r=50+60*s;  g=160+60*s;  b=220-40*s; }
        else if (t < 0.7) { const s=(t-0.5)/0.2; r=110+90*s; g=220-20*s;  b=180-80*s; }
        else               { const s=(t-0.7)/0.3; r=200+50*s; g=200-80*s;  b=100-60*s; }
    }
    return [Math.round(r), Math.round(g), Math.round(b)];
}

function renderHeatmaps() {
    heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);
    // Determine which heatmaps to render
    const jobs = [];
    if (layerState.sst_heat && allTempPoints.length >= 3) {
        jobs.push({ pts: allTempPoints, vmin: 14, vmax: 30, scheme: 'thermal', maxDist: 500, baseAlpha: 0.65 });
    }
    if (layerState.do_field && allDOPoints.length >= 2) {
        jobs.push({ pts: allDOPoints, vmin: 0, vmax: 10, scheme: 'oxygen', maxDist: 400, baseAlpha: 0.70 });
    }
    if (layerState.water_level && allWLPoints.length >= 3) {
        jobs.push({ pts: allWLPoints, vmin: -0.5, vmax: 1.0, scheme: 'tidal', maxDist: 300, baseAlpha: 0.55 });
    }
    if (jobs.length === 0) return;

    const w = heatCanvas.width, h = heatCanvas.height;
    const cellSize = 10;
    const pw = 2;  // IDW power parameter
    const imgData = heatCtx.createImageData(w, h);
    const pixels = imgData.data;

    for (const job of jobs) {
        // Pre-compute screen coords
        const screenPts = job.pts.map(p => {
            const sp = map.latLngToContainerPoint([p.lat, p.lon]);
            return { x: sp.x, y: sp.y, v: p.val };
        }).filter(p => p.x > -500 && p.x < w + 500 && p.y > -500 && p.y < h + 500);
        if (screenPts.length < 2) continue;

        for (let sy = 0; sy < h; sy += cellSize) {
            for (let sx = 0; sx < w; sx += cellSize) {
                let wSum = 0, vSum = 0, minDist = Infinity;
                for (const p of screenPts) {
                    const dx = sx - p.x, dy = sy - p.y;
                    const d = Math.sqrt(dx * dx + dy * dy);
                    if (d < minDist) minDist = d;
                    if (d < 1) { wSum = 1; vSum = p.v; break; }
                    const wt = 1 / Math.pow(d, pw);
                    wSum += wt; vSum += wt * p.v;
                }
                if (minDist > job.maxDist || wSum === 0) continue;
                const val = vSum / wSum;
                const [cr, cg, cb] = idwColormap(val, job.vmin, job.vmax, job.scheme);
                const alpha = Math.max(0, Math.min(job.baseAlpha, (1 - minDist / job.maxDist) * (job.baseAlpha + 0.1)));
                for (let cy = sy; cy < Math.min(sy + cellSize, h); cy++) {
                    for (let cx = sx; cx < Math.min(sx + cellSize, w); cx++) {
                        const idx = (cy * w + cx) * 4;
                        // Alpha-blend additive (multiple heatmaps can overlap)
                        const a = alpha * 255;
                        const existing = pixels[idx + 3];
                        if (existing === 0) {
                            pixels[idx] = cr; pixels[idx+1] = cg; pixels[idx+2] = cb; pixels[idx+3] = Math.round(a);
                        } else {
                            const blend = a / (existing + a);
                            pixels[idx]   = Math.round(pixels[idx]   * (1-blend) + cr * blend);
                            pixels[idx+1] = Math.round(pixels[idx+1] * (1-blend) + cg * blend);
                            pixels[idx+2] = Math.round(pixels[idx+2] * (1-blend) + cb * blend);
                            pixels[idx+3] = Math.min(255, Math.round(existing + a * 0.5));
                        }
                    }
                }
            }
        }
    }
    heatCtx.putImageData(imgData, 0, 0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WIND BARBS (Canvas overlay from NDBC met data)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderWindBarbs() {
    windCtx.clearRect(0, 0, windCanvas.width, windCanvas.height);
    if (!layerState.wind || !ndbcMetData) return;

    const zoom = map.getZoom();
    const barbLen = Math.max(16, zoom * 3.5);

    (ndbcMetData.buoys || []).forEach(b => {
        if (!b.current || b.current.wspd == null || b.current.wdir == null) return;
        const pt = map.latLngToContainerPoint([b.lat, b.lon]);
        if (pt.x < -20 || pt.x > windCanvas.width + 20 || pt.y < -20 || pt.y > windCanvas.height + 20) return;

        const wspd = b.current.wspd;  // m/s
        const wdir = (b.current.wdir - 90) * Math.PI / 180;  // Convert to math angle

        const kts = wspd * 1.94384;  // Convert to knots for barb convention
        const endX = pt.x + Math.cos(wdir) * barbLen;
        const endY = pt.y + Math.sin(wdir) * barbLen;

        // Staff
        windCtx.beginPath();
        windCtx.moveTo(pt.x, pt.y);
        windCtx.lineTo(endX, endY);
        windCtx.strokeStyle = 'rgba(220, 220, 220, 0.7)';
        windCtx.lineWidth = 1.2;
        windCtx.stroke();

        // Barbs (simplified: full barb = 10kt, half = 5kt, flag = 50kt)
        let remaining = kts;
        let barbPos = 0;
        const perpX = -Math.sin(wdir) * barbLen * 0.35;
        const perpY = Math.cos(wdir) * barbLen * 0.35;
        const step = barbLen * 0.18;

        // Flags (50kt)
        while (remaining >= 50) {
            const bx = endX - Math.cos(wdir) * barbPos;
            const by = endY - Math.sin(wdir) * barbPos;
            windCtx.beginPath();
            windCtx.moveTo(bx, by);
            windCtx.lineTo(bx + perpX, by + perpY);
            windCtx.lineTo(bx - Math.cos(wdir) * step, by - Math.sin(wdir) * step);
            windCtx.fillStyle = 'rgba(220, 220, 220, 0.7)';
            windCtx.fill();
            barbPos += step;
            remaining -= 50;
        }
        // Full barbs (10kt)
        while (remaining >= 10) {
            const bx = endX - Math.cos(wdir) * barbPos;
            const by = endY - Math.sin(wdir) * barbPos;
            windCtx.beginPath();
            windCtx.moveTo(bx, by);
            windCtx.lineTo(bx + perpX, by + perpY);
            windCtx.strokeStyle = 'rgba(220, 220, 220, 0.7)';
            windCtx.lineWidth = 1;
            windCtx.stroke();
            barbPos += step;
            remaining -= 10;
        }
        // Half barb (5kt)
        if (remaining >= 5) {
            const bx = endX - Math.cos(wdir) * barbPos;
            const by = endY - Math.sin(wdir) * barbPos;
            windCtx.beginPath();
            windCtx.moveTo(bx, by);
            windCtx.lineTo(bx + perpX * 0.5, by + perpY * 0.5);
            windCtx.strokeStyle = 'rgba(220, 220, 220, 0.7)';
            windCtx.lineWidth = 1;
            windCtx.stroke();
        }

        // Circle at base for calm
        if (kts < 3) {
            windCtx.beginPath();
            windCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
            windCtx.strokeStyle = 'rgba(220, 220, 220, 0.5)';
            windCtx.lineWidth = 1;
            windCtx.stroke();
        }
    });
    setCount('wind-count', (ndbcMetData.buoys || []).filter(b => b.current && b.current.wspd != null).length);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WAVE CIRCLES (pulsing proportional circles)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderWaveCircles() {
    if (!layerState.waves || !ndbcMetData) return;
    // Remove old wave layer if exists
    if (leafletLayers.waves) map.removeLayer(leafletLayers.waves);
    const group = L.layerGroup(); let count = 0;
    (ndbcMetData.buoys || []).forEach(b => {
        if (!b.current || b.current.wvht == null) return; count++;
        const wvht = b.current.wvht;
        const radius = Math.max(3, Math.min(15, wvht * 4));
        const color = wvht < 1 ? '#60a5fa' : wvht < 2 ? '#38bdf8' : wvht < 3 ? '#f59e0b' : '#ef4444';
        L.circleMarker([b.lat, b.lon], {
            radius, color, fillColor: color, fillOpacity: 0.4, weight: 1.5
        }).addTo(group).bindPopup(`<div style="font-weight:600;font-size:13px">${b.title || b.id}</div>
            <div style="font-family:'JetBrains Mono',monospace;font-size:12px;margin-top:6px">
            Wave Height: <span style="color:${color};font-weight:600">${wvht.toFixed(1)} m</span><br>
            ${b.current.dpd != null ? 'Period: ' + b.current.dpd.toFixed(0) + ' s' : ''}</div>`);
    });
    leafletLayers.waves = group;
    if (layerState.waves) group.addTo(map);
    setCount('wave-count', count);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER TOGGLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleLayer(name) {
    layerState[name] = !layerState[name];
    const el = document.querySelector(`.layer-toggle[data-layer="${name}"]`);
    if (el) el.classList.toggle('active', layerState[name]);

    // Canvas layers (re-render)
    if (name === 'currents') {
        if (!layerState.currents) clearCanvas();
    } else if (name === 'sst_heat' || name === 'do_field' || name === 'water_level') {
        renderHeatmaps();
        updateHeatmapLegends();
        // Also toggle associated marker layers
        if (name === 'do_field' && leafletLayers.ndbc) {
            if (layerState.do_field) leafletLayers.ndbc.addTo(map); else map.removeLayer(leafletLayers.ndbc);
        }
        if (name === 'water_level' && leafletLayers.coops) {
            if (layerState.water_level) leafletLayers.coops.addTo(map); else map.removeLayer(leafletLayers.coops);
        }
    } else if (name === 'wind') {
        renderWindBarbs();
    } else if (name === 'waves') {
        renderWaveCircles();
        if (!layerState.waves && leafletLayers.waves) map.removeLayer(leafletLayers.waves);
    } else if (leafletLayers[name]) {
        if (layerState[name]) leafletLayers[name].addTo(map);
        else map.removeLayer(leafletLayers[name]);
    }
}
window.toggleLayer = toggleLayer;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEGEND MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHeatmapLegends() {
    const sst = document.getElementById('legend-sst');
    const dol = document.getElementById('legend-do');
    const wl = document.getElementById('legend-wl');
    if (sst) sst.style.display = layerState.sst_heat ? 'block' : 'none';
    if (dol) dol.style.display = layerState.do_field ? 'block' : 'none';
    if (wl) wl.style.display = layerState.water_level ? 'block' : 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function init() {
    initMap();

    // Phase 1: Core data (parallel)
    const [hasCurrents, ndbcCount] = await Promise.all([
        fetchCurrents(),
        loadNDBCHypoxia(),
    ]);

    // Phase 2: AQUAVIEW layers (parallel)
    setLoadingText('Loading AQUAVIEW collections...');
    const results = await Promise.all([
        loadNDBCMet(),
        loadCOOPS(),
        loadIOOS(),
        loadGliders(),
        loadIncidents(),
        loadPMEL(),
    ]);

    setCount('stat-sensors', totalSensors.toLocaleString());

    if (hasCurrents) {
        setLoadingText('Initializing particle system...');
        initParticles();
        requestAnimationFrame(animateParticles);
    }

    // Render spatial data layers
    renderHeatmaps();
    renderWindBarbs();
    renderWaveCircles();

    setTimeout(() => { document.getElementById('loading').classList.add('hidden'); }, 600);
}

init();
</script>
</body>
</html>
